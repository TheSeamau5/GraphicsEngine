Elm.Engine = Elm.Engine || {};
Elm.Engine.Shader = Elm.Engine.Shader || {};
Elm.Engine.Shader.GouraudShader = Elm.Engine.Shader.GouraudShader || {};
Elm.Engine.Shader.GouraudShader.make = function (_elm) {
   "use strict";
   _elm.Engine = _elm.Engine || {};
   _elm.Engine.Shader = _elm.Engine.Shader || {};
   _elm.Engine.Shader.GouraudShader = _elm.Engine.Shader.GouraudShader || {};
   if (_elm.Engine.Shader.GouraudShader.values)
   return _elm.Engine.Shader.GouraudShader.values;
   var _op = {},
   _N = Elm.Native,
   _U = _N.Utils.make(_elm),
   _L = _N.List.make(_elm),
   _P = _N.Ports.make(_elm),
   $moduleName = "Engine.Shader.GouraudShader";
   var gouraudShader = "\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\n\nvoid main(){\n  vec3 normal = normalize(vNormal);\n  vec3 viewVector = normalize(vViewPosition);\n  vec4 lightDirection = viewMatrix * vec4(light.position, 1.0);\n  vec3 lightVector = normalize(lightDirection.xyz);\n  vec3 pointHalfVector = normalize(lightVector + viewVector);\n  float pointDotHalfNormal = max(dot(normal, pointHalfVector), 0.0);\n\n\n  vec3 lightContribution = light.color * max(min(light.intensity, 1.0), 0.5);\n\n  vec3 emissiveContribution = material.emissive.color * material.emissive.strength;\n  vec3 ambientContribution = material.ambient.color * material.ambient.strength;\n\n  float diffuseFactor = max( dot(normal, lightVector), 0.0) / 2.0;\n  vec3 diffuseContribution = material.diffuse.color * material.diffuse.strength * diffuseFactor;\n  vec3 outputColor = vec3(0.0,0.0,0.0);\n\n  outputColor += 0.25 * ambientContribution;\n\n  outputColor += 0.25 * emissiveContribution;\n\n  outputColor += 0.25 * diffuseContribution;\n\n  float shininess = material.specular.strength * 100.0;\n  float specularFactor = material.specular.strength * pow( pointDotHalfNormal, shininess);\n  specularFactor *= diffuseFactor * (2.0  +  shininess) / 8.0;\n\n  if (diffuseFactor <= 0.0){\n    specularFactor = 0.0;\n  }\n\n  vec3 specularContribution = material.specular.color * specularFactor;\n\n  outputColor += 0.25 * specularContribution;\n\n  //outputColor *= lightContribution;\n\n  gl_FragColor = vec4(outputColor, 1.0);\n\n  /*vec3 materialColor = normalize(\n    emissiveContribution + ambientContribution +\n    diffuseContribution  + specularContribution\n  ) * sqrt(3.0);\n\n  vec3 outputColor = normalize(\n    lightContribution * materialColor\n  ) * sqrt(3.0);\n\n  gl_FragColor = vec4(outputColor, 1.0);*/\n\n}\n\n";
   _elm.Engine.Shader.GouraudShader.values = {_op: _op
                                             ,gouraudShader: gouraudShader};
   return _elm.Engine.Shader.GouraudShader.values;
};