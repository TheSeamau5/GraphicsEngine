[
{
  "name": "Engine",
  "comment": "The Graphics Engine Library contains several functions and types to\nmake constructing 3D Scenes more fun and easy to use.\n\nThe simplest possible program to construct a scene is:\n\n    main = render scene\n\nThis program renders a default Scene that simply displays a red cube.\n\n`scene` is just shorthand for the following record:\n\n    scene = {\n      camera   = camera,\n      light    = light,\n      objects  = [cube],\n      viewport = viewport\n    }\n\nAs you can see, a scene contains a camera, a light, a list of objects, and\na viewport.\n\nLets modify the scene to display a pyramid instead\n\n    main = render { scene | objects \u003c- [pyramid]}\n\nAs you can see, all it took was changing the value of the objects property.\n\nThis logic is applicable almost everywhere in the library. So, you could\nconstruct arbitrary scenes like.\n\n    myCube = {\n      cube | position \u003c- vec3 1 1 0,\n             rotation \u003c- vec3 45 45 0,\n             scale    \u003c- vec3 0.5 0.5 0.5 }\n\n    myPyramid = {\n      pyramid | scale \u003c- vec3 0.3 2.0 1.0 }\n\n    myCamera = {\n      camera | fieldOfView \u003c- 125 }\n\n    myScene = {\n      scene | camera  \u003c- myCamera,\n              objects \u003c- [myCube, myPyramid] }\n\n    main = render myScene\n\nAs you can see, the record syntax allows to change only what needs to be\nchanged and removes any unnecessary boilerplate.",
  "aliases": [
    {
      "name": "Viewport",
      "comment": "A Viewport is an object that is supposed to describe the target \"screen\"\nor \"context\" on to which a scene is rendered.\n\nA Viewport has dimensions consisting of a width and a height.",
      "args": [],
      "type": {
        "tag": "type",
        "name": "Viewport.Viewport"
      }
    },
    {
      "name": "Transform",
      "comment": "A transform is an object with a position, a rotation, and a scale.\nThis is mean to be able to represent linear transformations in space. As\nsuch, one can model where an object is (position), what is its orientation\n(rotation), and how large is it (scale).",
      "args": [
        "a"
      ],
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Transform.Transform"
        },
        "args": [
          {
            "tag": "var",
            "name": "a"
          }
        ]
      }
    },
    {
      "name": "Renderable",
      "comment": "Represent a renderable object. A renderable object is an Object with a\nTransform properties (position, rotation, and scale) in order to locate it\nphysically in world space. A renderable object also comes with a Material\nand a Mesh.\n\nA renderable uses its position, rotation, and scale to set its position,\nrotation and scale in world space respectively. The material describes how\nthe renderable object responds to light and draws itself. The mesh describes\nthe geometry of the renderable object (if it is a cube, a pyramid, etc...).",
      "args": [],
      "type": {
        "tag": "type",
        "name": "Renderable.Renderable"
      }
    },
    {
      "name": "Uniform",
      "comment": "Container type to hold all of the properties that are passed to GLSL\nas uniforms.",
      "args": [],
      "type": {
        "tag": "type",
        "name": "Uniform.Uniform"
      }
    },
    {
      "name": "Attribute",
      "comment": "Attribute type. This type, from its fields, captures all of the\nattributes that are passed to the vertex shader.\n\nCurrenly only contains a position field.",
      "args": [],
      "type": {
        "tag": "type",
        "name": "Attribute.Attribute"
      }
    },
    {
      "name": "Mesh",
      "comment": "Mesh type. A mesh is simply a list of triangles where each vertex\nhas some property (in this case, just the position property). This type is\nused to construct arbitrary geometry that can be sent to the GPU to be\nrendered to the screen.\n\nFor reference, Triangle just a 3-tuple:\n\n    type alias Triangle a = (a, a, a)\n\nand Attribute is just a record type with a position field:\n\n    type alias Attribute = {\n      position : Vec3\n    }",
      "args": [],
      "type": {
        "tag": "type",
        "name": "Mesh.Mesh"
      }
    },
    {
      "name": "Material",
      "comment": "Represent a material. A Material has properties to help it define\nand adapt how it reacts to light.\n\nEmissive usually models light that seems to emanate from the object itself.\n\nAmbient usually represents some ambient term so that objects may be somewhat\nvisible in the dark. (to compensate for not using a ray tracer)\n\nDiffuse usually models the scatter of light on a surface. Rough objects\ntend to have a high diffuse strength as the light's reflection does not\nseem to focus on a small area but rather \"diffuses\" or spreads on the entire\nsurface.\n\nSpecular usually models specular highlights, or shinyness. Metallic objects\ntend to have a high specular strength as they seem to almost act as a\nmirror and a light's reflection seems to focus on a small area.\n\nNote: Diffuse and Specular are completely independent, they seem\nto be opposites but you can perfectly have a material with both high diffuse\nand specular strengths and you can also perfectly have a material with both\nlow diffuse and specular strengths.\n\nA Material also has a vertex shader and a fragment shader. A Shader is a\nprogram that is sent to the GPU (Graphics Processing Unit).\n\nThe vertex shader controls where a point is displayed on the screen. Usually,\nit suffices to just have a vertex shader that converts a position from world\ncoordinates to screen coodinates.\n\nThe fragment shader controls what color a given fragment (just think pixel) has.\nFragment shaders can often get very involved as they often calculate\nthe contributions due to all the light sources in a scene and somehow mix\nthis with the position, normal, and material properties of an object to\nfinally get a pixel color.\n\nNote: Both the vertex and fragment shaders are written in the GLSL\nprogramming language. To use your own shaders simply make sure to pass them\nto a material as a String.",
      "args": [],
      "type": {
        "tag": "type",
        "name": "Material.Material"
      }
    },
    {
      "name": "MaterialProperty",
      "comment": "Represent a property of a material. Contains a color and a strength.\nBy convention, full strength is set at 1 an no strength is 0,\ncolor values are between 0 and 1 (not 0 - 255).\n\nExample (creating a white specular property at full strength):\n\n    specularProperty = MaterialProperty (vec3 1 1 1) 1\n\nFrom the above, the specularProperty variable is given a white color and\nfull strength. If this property is used to represent specular highlights,\nthen this means that these highlights will appear white and very visible.",
      "args": [],
      "type": {
        "tag": "type",
        "name": "Material.MaterialProperty"
      }
    },
    {
      "name": "Light",
      "comment": "Represent a light in a scene. As a transform, a light has a position,\na rotation, and a scale. A light also has an intensity property\nto control the strength of the influence of the light source in the scene,\na color property, and a visibility property to act as a flag to toggle\na light on and off.\n\nNote: By convention, full intensity is set a 1 and no intensity is 0,\ncolor values are values between 0 and 1 (not 0 - 255).\n\nExample 1 : (A red light at full intensity)\n\n    redLight = {\n      position   = vec3 0 0 0,\n      rotation   = vec3 0 0 0,\n      scale      = vec3 1 1 1,\n      intensity  = 1,\n      color      = vec3 1 0 0,\n      visibility = True }\n\nExample 2 : (A white light at half intensity)\n\n    whiteLight =\n      { redLight | color     \u003c- vec3 1 1 1,\n                   intensity \u003c- 0.5}",
      "args": [],
      "type": {
        "tag": "type",
        "name": "Light.Light"
      }
    },
    {
      "name": "Camera",
      "comment": "Represent a perspective camera. As a transform, a camera has a\nposition, a rotation, and a scale. A camera also has an aspect ratio,\na field of view, a near clipping plane, and a far clipping plane. In essence,\na camera describes a viewing frustrum.\n\nNote : By convention, aspectRatio is a ratio (so a 4 : 3 aspect ratio\ncan be achieved by setting aspectRatio to 4 / 3 or 1.3), fieldOfView is\nset in degrees (45 being usually a good safe bet), nearClipping and\nfarClipping are set in world coordinates.\n\nExample 1 : (A typical 4 : 3 camera)\n\n    fourThirdsCamera = {\n      position      = vec3 0 0 0,\n      rotation      = vec3 0 0 0,\n      scale         = vec3 1 1 1,\n      aspectRatio   = 4 / 3,\n      fieldOfView   = 45,\n      nearClipping  = 1,\n      farClipping   = 80000 }\n\nExample 2 : (A 16 : 9 camera that cannot see far and warped field of view)\n\n    weirdSixteenNinthsCamera = {\n      fourThirdsCamera | aspectRatio \u003c- 16 / 9,\n      fieldOfView \u003c- 125,\n      farClipping \u003c- 10 }",
      "args": [],
      "type": {
        "tag": "type",
        "name": "Camera.Camera"
      }
    },
    {
      "name": "Scene",
      "comment": "Represents a scene. A scene contains a list of objects such that\ncalling `render` on a scene will render all the objects in a webgl context.\n\nA scene contains a camera to define the viewer's viewing point, a light to\nilluminate the scene, and a viewport to describe the context on which the\nscene will be drawn.",
      "args": [],
      "type": {
        "tag": "type",
        "name": "Scene.Scene"
      }
    }
  ],
  "types": [],
  "values": [
    {
      "name": "camera",
      "comment": "Default camera on a scene. Defines a camera at position x = 0, y = 0,\nz = -10, with a square aspect ratio (aspectRatio == 1), a field of view of\n45 degrees (fieldOfView == 45), a near clipping plane at 1 and a far\nclipping plane at 80000.\n\nExample : Constructing a standard widescreen cinema camera\n\n    widescreenCamera = { camera | aspectRatio \u003c- 2.39 }",
      "type": {
        "tag": "type",
        "name": "Camera"
      }
    },
    {
      "name": "cube",
      "comment": "Default cube renderable object",
      "type": {
        "tag": "type",
        "name": "Renderable"
      }
    },
    {
      "name": "cubeMesh",
      "comment": "Function that takes a center point/vector and a size and returns a\ncube mesh.\n\n    cube center size",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Vec3"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Float"
          },
          "out": {
            "tag": "type",
            "name": "Mesh"
          }
        }
      }
    },
    {
      "name": "light",
      "comment": "Default light on a scene. Defines a white light at full intensity\nat position x = 1, y = 1 , z = 3.\n\nThis is ideal for constructing custom lights just by updating the properties\nyou wish to update.\n\nExample : Constructing a green light\n\n    greenLight = { light | color \u003c- vec3 0 1 0 }",
      "type": {
        "tag": "type",
        "name": "Light"
      }
    },
    {
      "name": "material",
      "comment": "Default material. Defines a material with a weak white ambient and no\nemissive, diffuse, or specular terms. (i.e. a simple flat material)\n\nThe current default shaders are a standard vertex shader that converts from\nworld to screen coordinates and a fragment shader that just returns a red pixel.\n\nThis is ideal for creating your own materials and to just use a simple\ndefault material.",
      "type": {
        "tag": "type",
        "name": "Material"
      }
    },
    {
      "name": "pyramid",
      "comment": "Default pyramid renderable object",
      "type": {
        "tag": "type",
        "name": "Renderable"
      }
    },
    {
      "name": "pyramidMesh",
      "comment": "Function that takes a center point/vector, a height and a width and\nreturns a pyramid mesh.\n\n    pyramidMesh center height width",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Vec3"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Float"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Float"
            },
            "out": {
              "tag": "type",
              "name": "Mesh"
            }
          }
        }
      }
    },
    {
      "name": "rectangle",
      "comment": "Default rectangle renderable object",
      "type": {
        "tag": "type",
        "name": "Renderable"
      }
    },
    {
      "name": "rectangleMesh",
      "comment": "Function that takes 4 points and construct a rectangle mesh.\n\nNote: Actually, this function constructs two triangles. This means that\nit does not explicitly check if all 4 points are co-planar.\n\nFurthermore, the function does not enforce a rectangle's property that\nopposite sides be of equal length and that adjacent sides be perpendicular.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Vec3"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Vec3"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Vec3"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "Vec3"
              },
              "out": {
                "tag": "type",
                "name": "Mesh"
              }
            }
          }
        }
      }
    },
    {
      "name": "render",
      "comment": "Function to render a scene to a WebGL canvas context. This function takes\nin a Scene and returns the WebGL canvas context.\n\nNote: The function renders only the objects in the objects list of the scene.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Scene"
        },
        "out": {
          "tag": "type",
          "name": "Element"
        }
      }
    },
    {
      "name": "renderable",
      "comment": "Default renderable object. Alias for the default cube object.",
      "type": {
        "tag": "type",
        "name": "Renderable"
      }
    },
    {
      "name": "scene",
      "comment": "Default scene object. Draws a red cube in the middle of the default context.",
      "type": {
        "tag": "type",
        "name": "Scene"
      }
    },
    {
      "name": "transform",
      "comment": "Default transform.\n\nDefined as follows:\n\n    transform = {\n      position = vec3 0 0 0,\n      rotation = vec3 0 0 0,\n      scale    = vec3 1 1 1 }",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Transform"
        },
        "args": [
          {
            "tag": "record",
            "extension": null,
            "fields": []
          }
        ]
      }
    },
    {
      "name": "triangle",
      "comment": "Default triangle renderable object",
      "type": {
        "tag": "type",
        "name": "Renderable"
      }
    },
    {
      "name": "triangleMesh",
      "comment": "Function to construct a triangle mesh from three points.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Vec3"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Vec3"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Vec3"
            },
            "out": {
              "tag": "type",
              "name": "Mesh"
            }
          }
        }
      }
    },
    {
      "name": "viewport",
      "comment": "Default Viewport. Sets dimensions.width = 400 and dimensions.height = 400.\n(In essence, with the default viewport object your scene will appear in\na 400 by 400 canvas or webgl context).",
      "type": {
        "tag": "type",
        "name": "Viewport"
      }
    }
  ]
}
,
{
  "name": "Engine.Camera.Camera",
  "comment": "This module defines the Camera type and the default camera object.\nA Camera is a record type made to be the viewing point of a scene and thus\nenable the drawing of a scene to the screen. A Camera represents\na perspective camera.\n\n# Definition\n@docs Camera\n\n# Default Camera\n@docs camera",
  "aliases": [
    {
      "name": "Camera",
      "comment": "Represent a perspective camera. As a transform, a camera has a\nposition, a rotation, and a scale. A camera also has an aspect ratio,\na field of view, a near clipping plane, and a far clipping plane. In essence,\na camera describes a viewing frustrum.\n\nNote : By convention, aspectRatio is a ratio (so a 4 : 3 aspect ratio\ncan be achieved by setting aspectRatio to 4 / 3 or 1.3), fieldOfView is\nset in degrees (45 being usually a good safe bet), nearClipping and\nfarClipping are set in world coordinates.\n\nExample 1 : (A typical 4 : 3 camera)\n\n    fourThirdsCamera = {\n      position      = vec3 0 0 0,\n      rotation      = vec3 0 0 0,\n      scale         = vec3 1 1 1,\n      aspectRatio   = 4 / 3,\n      fieldOfView   = 45,\n      nearClipping  = 1,\n      farClipping   = 80000 }\n\nExample 2 : (A 16 : 9 camera that cannot see far and warped field of view)\n\n    weirdSixteenNinthsCamera = {\n      fourThirdsCamera | aspectRatio \u003c- 16 / 9,\n                         fieldOfView \u003c- 125,\n                         farClipping \u003c- 10 }",
      "args": [],
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Transform"
        },
        "args": [
          {
            "tag": "record",
            "extension": null,
            "fields": [
              [
                "aspectRatio",
                {
                  "tag": "type",
                  "name": "Float"
                }
              ],
              [
                "fieldOfView",
                {
                  "tag": "type",
                  "name": "Float"
                }
              ],
              [
                "nearClipping",
                {
                  "tag": "type",
                  "name": "Float"
                }
              ],
              [
                "farClipping",
                {
                  "tag": "type",
                  "name": "Float"
                }
              ]
            ]
          }
        ]
      }
    }
  ],
  "types": [],
  "values": [
    {
      "name": "camera",
      "comment": "Default camera on a scene. Defines a camera at position x = 0, y = 0,\nz = -10, with a square aspect ratio (aspectRatio == 1), a field of view of\n45 degrees (fieldOfView == 45), a near clipping plane at 1 and a far\nclipping plane at 80000.\n\nExample : Constructing a standard widescreen cinema camera\n\n    widescreenCamera = { camera | aspectRatio \u003c- 2.39 }",
      "type": {
        "tag": "type",
        "name": "Camera"
      }
    }
  ]
}
,
{
  "name": "Engine.Light.Light",
  "comment": "This module defines the Light type and the default light object.\nA Light is a record type made to illuminate scenes and objects in these\nscenes.\n\n# Definition\n@docs Light\n\n# Default Light\n@docs light",
  "aliases": [
    {
      "name": "Light",
      "comment": "Represent a light in a scene. As a transform, a light has a position,\na rotation, and a scale. A light also has an intensity property\nto control the strength of the influence of the light source in the scene,\na color property, and a visibility property to act as a flag to toggle\na light on and off.\n\nNote: By convention, full intensity is set a 1 and no intensity is 0,\ncolor values are values between 0 and 1 (not 0 - 255).\n\nExample 1 : (A red light at full intensity)\n\n    redLight = {\n      position   = vec3 0 0 0,\n      rotation   = vec3 0 0 0,\n      scale      = vec3 1 1 1,\n      intensity  = 1,\n      color      = vec3 1 0 0,\n      visibility = True }\n\nExample 2 : (A white light at half intensity)\n\n    whiteLight =\n      { redLight | color     \u003c- vec3 1 1 1,\n                   intensity \u003c- 0.5}",
      "args": [],
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Transform"
        },
        "args": [
          {
            "tag": "record",
            "extension": null,
            "fields": [
              [
                "intensity",
                {
                  "tag": "type",
                  "name": "Float"
                }
              ],
              [
                "color",
                {
                  "tag": "type",
                  "name": "Vec3"
                }
              ],
              [
                "visibility",
                {
                  "tag": "type",
                  "name": "Bool"
                }
              ]
            ]
          }
        ]
      }
    }
  ],
  "types": [],
  "values": [
    {
      "name": "light",
      "comment": "Default light on a scene. Defines a white light at full intensity\nat position x = 1, y = 1 , z = 3.\n\nThis is ideal for constructing custom lights just by updating the properties\nyou wish to update.\n\nExample : Constructing a green light\n\n    greenLight = { light | color \u003c- vec3 0 1 0 }",
      "type": {
        "tag": "type",
        "name": "Light"
      }
    }
  ]
}
,
{
  "name": "Engine.Material.Material",
  "comment": "This module defined the Material type and the default material object.\nA Material is a record type made to define how an object reacts to light\nin a scene and draws itself.\n\n# Definition\n@docs Material\n\n# Default Material\n@docs material\n\n# Convenient Helper Type\n@docs MaterialProperty",
  "aliases": [
    {
      "name": "Material",
      "comment": "Represent a material. A Material has properties to help it define\nand adapt how it reacts to light.\n\nEmissive usually models light that seems to emanate from the object itself.\n\nAmbient usually represents some ambient term so that objects may be somewhat\nvisible in the dark. (to compensate for not using a ray tracer)\n\nDiffuse usually models the scatter of light on a surface. Rough objects\ntend to have a high diffuse strength as the light's reflection does not\nseem to focus on a small area but rather \"diffuses\" or spreads on the entire\nsurface.\n\nSpecular usually models specular highlights, or shinyness. Metallic objects\ntend to have a high specular strength as they seem to almost act as a\nmirror and a light's reflection seems to focus on a small area.\n\nNote: Diffuse and Specular are completely independent, they seem\nto be opposites but you can perfectly have a material with both high diffuse\nand specular strengths and you can also perfectly have a material with both\nlow diffuse and specular strengths.\n\nA Material also has a vertex shader and a fragment shader. A Shader is a\nprogram that is sent to the GPU (Graphics Processing Unit).\n\nThe vertex shader controls where a point is displayed on the screen. Usually,\nit suffices to just have a vertex shader that converts a position from world\ncoordinates to screen coodinates.\n\nThe fragment shader controls what color a given fragment (just think pixel) has.\nFragment shaders can often get very involved as they often calculate\nthe contributions due to all the light sources in a scene and somehow mix\nthis with the position, normal, and material properties of an object to\nfinally get a pixel color.\n\nNote: Both the vertex and fragment shaders are written in the GLSL\nprogramming language. To use your own shaders simply make sure to pass them\nto a material as a String.",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "emissive",
            {
              "tag": "type",
              "name": "MaterialProperty"
            }
          ],
          [
            "ambient",
            {
              "tag": "type",
              "name": "MaterialProperty"
            }
          ],
          [
            "diffuse",
            {
              "tag": "type",
              "name": "MaterialProperty"
            }
          ],
          [
            "specular",
            {
              "tag": "type",
              "name": "MaterialProperty"
            }
          ],
          [
            "vertexShader",
            {
              "tag": "type",
              "name": "String"
            }
          ],
          [
            "fragmentShader",
            {
              "tag": "type",
              "name": "String"
            }
          ]
        ]
      }
    },
    {
      "name": "MaterialProperty",
      "comment": "Represent a property of a material. Contains a color and a strength.\nBy convention, full strength is set at 1 an no strength is 0,\ncolor values are between 0 and 1 (not 0 - 255).\n\nExample (creating a white specular property at full strength):\n\n    specularProperty = MaterialProperty (vec3 1 1 1) 1\n\nFrom the above, the specularProperty variable is given a white color and\nfull strength. If this property is used to represent specular highlights,\nthen this means that these highlights will appear white and very visible.",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "color",
            {
              "tag": "type",
              "name": "Vec3"
            }
          ],
          [
            "strength",
            {
              "tag": "type",
              "name": "Float"
            }
          ]
        ]
      }
    }
  ],
  "types": [],
  "values": [
    {
      "name": "material",
      "comment": "Default material. Defines a material with a weak white ambient and no\nemissive, diffuse, or specular terms. (i.e. a simple flat material)\n\nThe current default shaders are a standard vertex shader that converts from\nworld to screen coordinates and a fragment shader that just returns a red pixel.\n\nThis is ideal for creating your own materials and to just use a simple\ndefault material.",
      "type": {
        "tag": "type",
        "name": "Material"
      }
    }
  ]
}
,
{
  "name": "Engine.Math.Utils",
  "comment": "This module is just a simple collection of mathematical operations\nused repeatedly in several areas in the Graphics Engine codebase.\n\n# \"Safe\" versions of Linear Algbera operations\n@docs safeNormalize, safeMakeRotate\n\n# Common Camera operations\n@docs getSideVector, getUpVector, getForwardVector, getTargetPosition\n\n# Model View Projection\n@docs modelMatrix, viewMatrix, projectionMatrix\n\n# Renaming Functions to avoid Namespace clashes\n@docs matrixIdentity",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "getForwardVector",
      "comment": "Calculate the vector pointing outward of a transform given a position\nand rotation. This is mainly used by cameras to help orient themselves\nand create the view matrix.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Transform"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "Vector3.Vec3"
        }
      }
    },
    {
      "name": "getSideVector",
      "comment": "Calculate the right-handed side vector of a transform. This is mainly\nused by cameras to help orient themselves.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Transform"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "Vector3.Vec3"
        }
      }
    },
    {
      "name": "getTargetPosition",
      "comment": "Calculate the target position of a transform (i.e. where the transform\npoints at). This is mainly used to figure out what a camera points at.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Transform"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "Vector3.Vec3"
        }
      }
    },
    {
      "name": "getUpVector",
      "comment": "Calculate the right-handed up vector of a transform. This is mainly\nused by cameras to help orient themselves and create the view matrix.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Transform"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "Vector3.Vec3"
        }
      }
    },
    {
      "name": "matrixIdentity",
      "comment": "Renaming of the identity matrix because it clashes with the identity\nfunction in Basics which defines the function that just returns its input",
      "type": {
        "tag": "type",
        "name": "Matrix4.Mat4"
      }
    },
    {
      "name": "modelMatrix",
      "comment": "The model matrix. Encodes the transformation of a transform as a matrix.\nThis allows to efficiently apply such a transformation to a point to move it\nin world space with a given position, rotation, and scale.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Transform"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "Matrix4.Mat4"
        }
      }
    },
    {
      "name": "projectionMatrix",
      "comment": "The projection matrix. Encodes the perspective matrix of a camera.\nThis allows to map a position from camera space to screen space.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Camera"
        },
        "out": {
          "tag": "type",
          "name": "Matrix4.Mat4"
        }
      }
    },
    {
      "name": "safeMakeRotate",
      "comment": "Version of Matrix4.makeRotate which simply returns the identity\nmatrix if the input rotation vector is the zero vector\n\nIn essence,\n\n    safeMakeRotate (vec3 0 0 0) == Matrix4.identity",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Vector3.Vec3"
        },
        "out": {
          "tag": "type",
          "name": "Matrix4.Mat4"
        }
      }
    },
    {
      "name": "safeNormalize",
      "comment": "Version of Vector3.normalize which simply returns the vector to be\nnormalized untouched in the case its length is equal to zero\n\nIn essence,\n\n    safeNormalize (vec3 0 0 0) == vec3 0 0 0",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Vector3.Vec3"
        },
        "out": {
          "tag": "type",
          "name": "Vector3.Vec3"
        }
      }
    },
    {
      "name": "viewMatrix",
      "comment": "The view matrix. Encodes the Look At matrix of a transform.\nThis allows to calculate the Look At matrix of a camera to then multiply\na position by the view matrix in order to convert it from world space to\ncamera space.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Transform"
          },
          "args": [
            {
              "tag": "var",
              "name": "a"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "Matrix4.Mat4"
        }
      }
    }
  ]
}
,
{
  "name": "Engine.Mesh.Mesh",
  "comment": "This module contains the definition of the mesh type\n\n# Mesh Type\n@docs Mesh",
  "aliases": [
    {
      "name": "Mesh",
      "comment": "Mesh type. A mesh is simply a list of triangles where each vertex\nhas some property (in this case, just the position property). This type is\nused to construct arbitrary geometry that can be sent to the GPU to be\nrendered to the screen.\n\nFor reference, Triangle just a 3-tuple:\n\n    type alias Triangle a = (a, a, a)\n\nand Attribute is just a record type with a position field:\n\n    type alias Attribute = {\n      position : Vec3\n    }",
      "args": [],
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "List"
        },
        "args": [
          {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "Triangle"
            },
            "args": [
              {
                "tag": "type",
                "name": "Attribute"
              }
            ]
          }
        ]
      }
    }
  ],
  "types": [],
  "values": []
}
,
{
  "name": "Engine.Mesh.Triangle",
  "comment": "This module contains the definition of a triangle mesh and of a triangle\nrenderable object. The triangle is the main building block of all geometry in\nmodern computer graphics. Use these functions if you want to create your own\ncustom geometry.\n\n# Triangle Mesh\n@docs triangleMesh\n\n# Triangle (Renderable)\n@docs triangle",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "triangle",
      "comment": "Default triangle renderable object",
      "type": {
        "tag": "type",
        "name": "Renderable"
      }
    },
    {
      "name": "triangleMesh",
      "comment": "Function to construct a triangle mesh from three points.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Vec3"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Vec3"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Vec3"
            },
            "out": {
              "tag": "type",
              "name": "Mesh"
            }
          }
        }
      }
    }
  ]
}
,
{
  "name": "Engine.Mesh.Rectangle",
  "comment": "This module contains the definition of a rectangle mesh and of a rectangle\nrenderable object.\n\n# Rectangle Mesh\n@docs rectangleMesh\n\n# Rectangle (Renderable)\n@docs rectangle",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "rectangle",
      "comment": "Default rectangle renderable object",
      "type": {
        "tag": "type",
        "name": "Renderable"
      }
    },
    {
      "name": "rectangleMesh",
      "comment": "Function that takes 4 points and construct a rectangle mesh.\n\nNote: Actually, this function constructs two triangles. This means that\nit does not explicitly check if all 4 points are co-planar.\n\nFurthermore, the function does not enforce a rectangle's property that\nopposite sides be of equal length and that adjacent sides be perpendicular.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Vec3"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Vec3"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Vec3"
            },
            "out": {
              "tag": "lambda",
              "in": {
                "tag": "type",
                "name": "Vec3"
              },
              "out": {
                "tag": "type",
                "name": "Mesh"
              }
            }
          }
        }
      }
    }
  ]
}
,
{
  "name": "Engine.Mesh.Pyramid",
  "comment": "This module contains the definition of a pyramid mesh and of a pyramid\nrenderable object.\n\n# Pyramid Mesh\n@docs pyramidMesh\n\n# Pyramid (Renderable)\n@docs pyramid",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "pyramid",
      "comment": "Default pyramid renderable object",
      "type": {
        "tag": "type",
        "name": "Renderable"
      }
    },
    {
      "name": "pyramidMesh",
      "comment": "Function that takes a center point/vector, a height and a width and\nreturns a pyramid mesh.\n\n      pyramidMesh center height width",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Vec3"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Float"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "Float"
            },
            "out": {
              "tag": "type",
              "name": "Mesh"
            }
          }
        }
      }
    }
  ]
}
,
{
  "name": "Engine.Mesh.Cube",
  "comment": "This module contains the definition of a cube mesh and of a cube\nrenderable object.\n\n# Cube Mesh\n@docs cubeMesh\n\n# Cube (Renderable)\n@docs cube",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "cube",
      "comment": "Default cube renderable object",
      "type": {
        "tag": "type",
        "name": "Renderable"
      }
    },
    {
      "name": "cubeMesh",
      "comment": "Function that takes a center point/vector and a size and returns a\ncube mesh.\n\n    cube center size",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Vec3"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Float"
          },
          "out": {
            "tag": "type",
            "name": "Mesh"
          }
        }
      }
    }
  ]
}
,
{
  "name": "Engine.Render.Renderable",
  "comment": "This module contains the definition of the Renderable type. This is\nseparated from the definition of the default renderable object in order to\navoid circular dependencies.\n\n# Definition\n@docs Renderable",
  "aliases": [
    {
      "name": "Renderable",
      "comment": "Represent a renderable object. A renderable object is an Object with a\nTransform properties (position, rotation, and scale) in order to locate it\nphysically in world space. A renderable object also comes with a Material\nand a Mesh.\n\nA renderable uses its position, rotation, and scale to set its position,\nrotation and scale in world space respectively. The material describes how\nthe renderable object responds to light and draws itself. The mesh describes\nthe geometry of the renderable object (if it is a cube, a pyramid, etc...).",
      "args": [],
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Transform"
        },
        "args": [
          {
            "tag": "record",
            "extension": null,
            "fields": [
              [
                "material",
                {
                  "tag": "type",
                  "name": "Material"
                }
              ],
              [
                "mesh",
                {
                  "tag": "type",
                  "name": "Mesh"
                }
              ]
            ]
          }
        ]
      }
    }
  ],
  "types": [],
  "values": []
}
,
{
  "name": "Engine.Render.DefaultRenderable",
  "comment": "This module contains the definition for the default Renderable renderable.\nThis definition is separated from the Renderable module in order to avoid\ncircular dependencies.\n\n\n# Default Renderable\n@docs renderable",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "renderable",
      "comment": "Default renderable object. Alias for the default cube object.",
      "type": {
        "tag": "type",
        "name": "Renderable"
      }
    }
  ]
}
,
{
  "name": "Engine.Render.Render",
  "comment": "This module contains functions to render objects and scenes onto\na WebGL canvas context.\n\n# Render Functions\n@docs renderObject, render",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "render",
      "comment": "Function to render a scene to a WebGL canvas context. This function takes\nin a Scene and returns the WebGL canvas context.\n\nNote: The function renders only the objects in the objects list of the scene.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Scene"
        },
        "out": {
          "tag": "type",
          "name": "Element"
        }
      }
    },
    {
      "name": "renderObject",
      "comment": "Function to render an object onto a scene. This function returns an\nEntity object which is what the webgl function from the WebGL library requires\nto draw anything onto a WebGL canvas context.\n\nNote: This function is mainly used as a helper function to render.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Scene"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Renderable"
          },
          "out": {
            "tag": "type",
            "name": "Entity"
          }
        }
      }
    }
  ]
}
,
{
  "name": "Engine.Scene.Scene",
  "comment": "This module defines the Scene type and the default Scene object.\nA Scene contains a camera (the viewer's window to the scene), a list of\nRenderable objects (the stuff that gets drawn to the scene), a light\n(something to illuminate the scene), and a Viewport (a description of\nthe context the scene gets drawn to).\n\nNote: Currently, Graphics Engine only supports having one light. In future\nreleases, this will most certainly change in order to support having multiple\nlights in a scene.\n\nNote: Currently, Graphics Engine onlu supports having one camera. While this\nmay be all you need in most cases, it may be valuable to allow for multiple\ncameras. Currently, the only way to have multiple cameras is to have\nmultiple scenes. It is still an open question on which approach is better.\n\n\n# Definition\n@docs Scene\n\n# Default Scene\n@docs scene",
  "aliases": [
    {
      "name": "Scene",
      "comment": "Represents a scene. A scene contains a list of objects such that\ncalling `render` on a scene will render all the objects in a webgl context.\n\nA scene contains a camera to define the viewer's viewing point, a light to\nilluminate the scene, and a viewport to describe the context on which the\nscene will be drawn.",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "camera",
            {
              "tag": "type",
              "name": "Camera"
            }
          ],
          [
            "objects",
            {
              "tag": "app",
              "func": {
                "tag": "type",
                "name": "List"
              },
              "args": [
                {
                  "tag": "type",
                  "name": "Renderable"
                }
              ]
            }
          ],
          [
            "light",
            {
              "tag": "type",
              "name": "Light"
            }
          ],
          [
            "viewport",
            {
              "tag": "type",
              "name": "Viewport"
            }
          ]
        ]
      }
    }
  ],
  "types": [],
  "values": [
    {
      "name": "scene",
      "comment": "Default scene object. Draws a red cube in the middle of the default context.",
      "type": {
        "tag": "type",
        "name": "Scene"
      }
    }
  ]
}
,
{
  "name": "Engine.Shader.Shader",
  "comment": "This module constains functions to construct shaders as well as\nfunctions to return shaders as strings (mostly for debugging purposes)\n\n# Construct Shaders\n@docs constructVertexShader, constructFragmentShader\n\n# Construct Shader Strings\n@docs showVertexShader, showFragmentShader",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "constructFragmentShader",
      "comment": "Construct a Fragment Shader from a String.\nThe input string contains a GLSL program. This function enables to automatically\nadd a whole bunch of boilerplate code, like setting the float precision, or\ndeclaring the structs and uniforms.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Shader"
          },
          "args": [
            {
              "tag": "record",
              "extension": null,
              "fields": []
            },
            {
              "tag": "type",
              "name": "Uniform"
            },
            {
              "tag": "var",
              "name": "varying"
            }
          ]
        }
      }
    },
    {
      "name": "constructVertexShader",
      "comment": "Construct a Vertex Shader from a String.\nThe input string contains a GLSL program. This function enables to automatically\nadd a whole bunch of boilerplate code, like setting the float precision, or\ndeclaring the uniforms and attributes.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "Shader"
          },
          "args": [
            {
              "tag": "type",
              "name": "Attribute"
            },
            {
              "tag": "type",
              "name": "Uniform"
            },
            {
              "tag": "var",
              "name": "varying"
            }
          ]
        }
      }
    },
    {
      "name": "showFragmentShader",
      "comment": "Function to construct a fragment shader as a String. Useful for debugging\npurposes.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "type",
          "name": "String"
        }
      }
    },
    {
      "name": "showVertexShader",
      "comment": "Function to construct a vertex shader as a String. Useful for debugging\npurposes.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "type",
          "name": "String"
        }
      }
    }
  ]
}
,
{
  "name": "Engine.Shader.Attribute",
  "comment": "This module contains the definition of the Attribute type.\nA vertex shader takes a set of attributes as input for each vertex.\nThe Attibute type is made to capture all of these attributes.\n\nCurrently, we only pass the position to the vertex shader as an attibute.\n\nTypically, a color and a normal is also passed as an attribute but for\nsimplicity it is highly encouraged to set the color at the material level\nand to retrieve the normal from the normal matrix (which is automatically\npassed as a uniform).\n\n# Definition\n@docs Attribute",
  "aliases": [
    {
      "name": "Attribute",
      "comment": "Attribute type. This type, from its fields, captures all of the\nattributes that are passed to the vertex shader.\n\nCurrenly only contains a position field.",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "position",
            {
              "tag": "type",
              "name": "Vec3"
            }
          ]
        ]
      }
    }
  ],
  "types": [],
  "values": []
}
,
{
  "name": "Engine.Shader.Uniform",
  "comment": "This module contains the definition of the Uniform type and\na function to construct a uniform from a scene and a renderable object\n\n# Definition\n@docs Uniform\n\n# Construct a Uniform\n@docs constructUniform",
  "aliases": [
    {
      "name": "Uniform",
      "comment": "Container type to hold all of the properties that are passed to GLSL\nas uniforms.",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "modelMatrix",
            {
              "tag": "type",
              "name": "Mat4"
            }
          ],
          [
            "viewMatrix",
            {
              "tag": "type",
              "name": "Mat4"
            }
          ],
          [
            "projectionMatrix",
            {
              "tag": "type",
              "name": "Mat4"
            }
          ],
          [
            "lightPosition",
            {
              "tag": "type",
              "name": "Vec3"
            }
          ],
          [
            "lightRotation",
            {
              "tag": "type",
              "name": "Vec3"
            }
          ],
          [
            "lightColor",
            {
              "tag": "type",
              "name": "Vec3"
            }
          ],
          [
            "lightIntensity",
            {
              "tag": "type",
              "name": "Float"
            }
          ],
          [
            "materialEmissiveColor",
            {
              "tag": "type",
              "name": "Vec3"
            }
          ],
          [
            "materialEmissiveStrength",
            {
              "tag": "type",
              "name": "Float"
            }
          ],
          [
            "materialAmbientColor",
            {
              "tag": "type",
              "name": "Vec3"
            }
          ],
          [
            "materialAmbientStrength",
            {
              "tag": "type",
              "name": "Float"
            }
          ],
          [
            "materialDiffuseColor",
            {
              "tag": "type",
              "name": "Vec3"
            }
          ],
          [
            "materialDiffuseStrength",
            {
              "tag": "type",
              "name": "Float"
            }
          ],
          [
            "materialSpecularColor",
            {
              "tag": "type",
              "name": "Vec3"
            }
          ],
          [
            "materialSpecularStrength",
            {
              "tag": "type",
              "name": "Float"
            }
          ]
        ]
      }
    }
  ],
  "types": [],
  "values": [
    {
      "name": "constructUniform",
      "comment": "Constructs a record of type Uniform from a scene and a renderable object\nto be sent to GLSL as uniforms.",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "Scene"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "Renderable"
          },
          "out": {
            "tag": "type",
            "name": "Uniform"
          }
        }
      }
    }
  ]
}
,
{
  "name": "Engine.Shader.Boilerplate",
  "comment": "This module exists to automatically handle some of the boilerplate\nthat comes with writing shaders.\n\n# Struct Definitions\n@docs materialPropertyStructTypeDefinition,\n      materialStructTypeDefinition,\n      lightStructTypeDefinition\n\n# Automatic Setup of Variables\n@docs setupMaterial, setupLight\n\n# Uniform Declarations\n@docs uniformDeclarations\n\n# Attribute Declarations\n@docs attributeDeclarations\n\n# Additional Useful Variables\n@docs usefulVariables\n\n# Boilerplate\n@docs vertexShaderBoilerplate, fragmentShaderBoilerplate",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "attributeDeclarations",
      "comment": "Set of attribute declarations. (available in vertex shader only)\n\nCurrently, the available attributes are:\n\n    attribute vec3 position;",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "commonShaderBoilerplate",
      "comment": "Details the common boilerplate shared in both vertex and fragment shaders.",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "fragmentShaderBoilerplate",
      "comment": "The boilerplate code found in the fragment shader.",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "lightStructTypeDefinition",
      "comment": "Definition of the struct Light.\n\nNote: Currently, this struct does not have the visibility property. This is\ndue to the fact that you cannot yet pass bools as uniforms with elm-webgl. As\nsuch it is ignored. Please take notice!\n\nNote: Currently, this struct does not contain the scale property. Given the\nlast refractoring, Lights are now defined as Transforms and as such contain\na scale property. This will be amended in a future release. Please take notice!\n\n    //GLSL CODE:\n\n    struct Light {\n      vec3 position;\n      vec3 rotation;\n      vec3 color;\n      float intensity;\n    };",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "materialPropertyStructTypeDefinition",
      "comment": "Definition of the struct MaterialProperty\n\n    //GLSL CODE:\n\n    struct MaterialProperty {\n      vec3 color;\n      float strength;\n    };",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "materialStructTypeDefinition",
      "comment": "Definition of the struct Material\n\n    //GLSL CODE:\n\n    struct Material {\n      MaterialProperty emissive;\n      MaterialProperty ambient;\n      MaterialProperty diffuse;\n      MaterialProperty specular;\n    };",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "modelViewMatrix",
      "comment": "Shorthand for the model view matrix. Available in both shaders.\n\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "modelViewProjectionMatrix",
      "comment": "Shorthand for the model view projection matrix. Available in both shaders.\n\n    mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "normalMatrix",
      "comment": "The normal matrix. Convenient to calculate surface normals.\n\n    mat4 normalMatrix = transpose(inverse(modelViewMatrix));",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "setupLight",
      "comment": "The setup for light. This is due to the fact that currently you\ncannot yet pass structs as uniforms with elm-webgl. As such, each underlying\nproperty is passed as a primitive type and then the struct is constructed\nfrom each of the properties.\n\nThanks to this process, you now have access to the variable :\n\n    Light light;\n\nAnd it contains all of the data you have defined in the Elm code usable in\nthe same way as in Elm.\n\nNote: Currently visibility and scale are unsupported!\n\nNote: Currently only one light is supported. This is due to the fact that\ncurrently you cannot yet pass arrays as uniforms with elm-wegl. I haven't\nthought of a good hack around this, sorry.",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "setupMaterial",
      "comment": "The setup for material. This is due to the fact that currently you\ncannot yet pass structs as uniforms with elm-webgl. As such, each underlying\nproperty is passed as a primitive type and then the struct is constructed\nfrom each of the properties.\n\nThanks to this process, you now have access to the variable :\n\n    Material material;\n\nAnd it contains all of the data you have defined in the Elm code usable in\nthe same way as in Elm.",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "uniformDeclarations",
      "comment": "Set of uniform declarations. (Available in both vertex and fragment shaders)\n\nCurrently, the available uniforms are:\n\n    uniform mat4 modelMatrix;\n    uniform mat4 viewMatrix;\n    uniform mat4 projectionMatrix;\n\n    uniform vec3  lightPosition;\n    uniform vec3  lightRotation;\n    uniform vec3  lightColor;\n    uniform float lightIntensity;\n\n    uniform vec3  materialEmissiveColor;\n    uniform float materialEmissiveStrength;\n\n    uniform vec3  materialAmbientColor;\n    uniform float materialAmbientStrength;\n\n    uniform vec3  materialDiffuseColor;\n    uniform float materialDiffuseStrength;\n\n    uniform vec3  materialSpecularColor;\n    uniform float materialSpecularStrength;",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "usefulVariables",
      "comment": "Set of useful variables for programming convenience.\n\nCurrently, the available useful variables are :\n\n    mat4 modelViewMatrix;\n    mat4 modelViewProjectionMatrix;\n    mat4 normalMatrix;",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "vertexShaderBoilerplate",
      "comment": "The boilerplate code found in the vertex shader.",
      "type": {
        "tag": "type",
        "name": "String"
      }
    }
  ]
}
,
{
  "name": "Engine.Shader.Library",
  "comment": "This module contains a set of strings that represent GLSL functions\nthat constitute a GLSL library to add common operations missing from\nWebGL's version of GLSL.\n\n# Matrix Functions\n@docs transposeFunction, determinantFunction, traceFunction, inverseFunction",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "determinantFunction",
      "comment": "GLSL Function to calculate the transpose of a 2, 3, or 4-Dimensional matrix\n\nThe determinant of a matrix represents the area of a parallelogram\n(in 2 dimensions), the volume of a parallelepiped (in 3 dimensions),\nor the hypervolume of a hyperrectangle.\n\nOne of the most common uses of a determinant is as a crucial step in calculating\nthe inverse of a matrix. The determiant can also be used as an efficient\ntest for the invertability of a matrix. A matrix is invertible if and\nonly if the determinant of the matrix is nonzero.\n\n    determinant(mat2(1.0, 3.0, 2.0, 12.0)) == 6.0;\n\n    determinant(identity4) == 1.0;",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "identityMatrix",
      "comment": "GLSL 2, 3, and 4 Identity Matrices\n\nThe Identity Matrix is the matrix that maps a vector to itself.\n\n    identity2 * vector2 == vector2;\n\n    identity3 * vector3 == vector3;\n\n    identity4 * modelMatrix == modelMatrix;",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "inverseFunction",
      "comment": "GLSL Function to calculate the inverse of a 2, 3, or 4-Dimensional matrix.\nNote: This function does not test for invertability. So, buyer beware.\n\nThe inverse of a matrix is basically like an undo matrix. A matrix\nmultiplied by its inverse yields the identity matrix and thus undoing\na matrix transformation on a vector is as simple as multiplying the\ntransformed vector by the inverse of that matrix transformation.\n\nA common use case for the inverse of a matrix is to convert screen\ncoordinates to world coordinates (by inverting modelViewProjectionMatrix).\nThis is useful screen-to-world raycasting (i.e. clicking on a 3-d object).\n\n    inverse(inverse(invertibleMatrix)) == invertibleMatrix;\n\n    inverse(identity3) == identity3;\n\n    inverse(projectionMatrix) * modelViewProjectionMatrix == modelViewMatrix;",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "libraryFunctions",
      "comment": "Set of functions included in the library\n\n    mat2 transpose(mat2);\n    mat3 transpose(mat3);\n    mat4 transpose(mat4);\n\n    float determinant(mat2);\n    float determinant(mat3);\n    float determinant(mat4);\n\n    mat2 trace(mat2);\n    mat3 trace(mat3);\n    mat4 trace(mat4);\n\n    mat2 inverse(mat2);\n    mat3 inverse(mat3);\n    mat4 inverse(mat4);",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "libraryVariables",
      "comment": "GLSL Set of variables included in the library\n\n    mat2 identity2;\n    mat3 identity3;\n    mat4 identity4;",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "mat2Determinant",
      "comment": "GLSL Function that computes the determinant of a 2-dimensional matrix\n\n    // GLSL CODE:\n    mat2 matrix = mat2(\n      1.0, 3.0,\n      2.0, 12.0\n    );\n    float matrixDeterminant = determinant(matrix);\n    // matrixDeterminant == 6.0",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "mat2Identity",
      "comment": "GLSL 2-Dimensional Identity Matrix\n\n    //GLSL CODE:\n\n    //identity2 == mat2(\n    //    1.0, 0.0,\n    //    0.0, 1.0\n    //);",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "mat2Inverse",
      "comment": "GLSL Function that computes the inverse of a 2-Dimensional matrix.\n\nThe 2-Dimensional Matrix inverse function is implemented directly\nby computing the determinant and hardcoding the matrix scaled\nby the inverse of the determinant.\n\n    // GLSL CODE:\n    mat2 matrix = mat2(\n      1.0, 2.0,\n      3.0, 4.0\n    );\n    mat2 matrixInverse = inverse(matrix);\n    //matrixInverse == mat2(\n    //  -2.0, 1.0,\n    //   1.5,-0.5\n    //);",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "mat2Trace",
      "comment": "GLSL Function that computes the trace of a 2-dimensional matrix\n\n    // GLSL CODE:\n    mat2 matrix = mat2(\n      2.0, 3.0,\n      5.0, 1.0\n    );\n    float matrixTrace = trace(matrix);\n    // matrixTrace == 3.0",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "mat2Transpose",
      "comment": "GLSL Function that computes the transpose of a 2-dimensional matrix.\n\n    // GLSL CODE:\n    mat2 matrix = mat2(\n      1.0, 2.0,\n      3.0, 4.0\n    );\n    mat2 transposedMatrix = transpose(matrix);\n    // transposedMatrix == mat2(\n    //      1.0, 3.0,\n    //      2.0, 4.0)",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "mat3Determinant",
      "comment": "GLSL Function that computes the determinant of a 3-dimensional matrix\n\n    // GLSL CODE:\n    mat3 matrix = mat3(\n      1.0, 0.0, 0.0,\n      0.0, 4.0, 0.0,\n      0.0, 0.0, 20.0\n    );\n    float matrixDeterminant = determinant(matrix);\n    // matrixDeterminant == 80.0",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "mat3Identity",
      "comment": "GLSL 3-Dimensional Identity Matrix\n\n    //GLSL CODE:\n\n    //identity3 == mat3(\n    //    1.0, 0.0, 0.0,\n    //    0.0, 1.0, 0.0,\n    //    0.0, 0.0, 1.0\n    //);",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "mat3Inverse",
      "comment": "GLSL Function that computes the inverse of a 3-Dimensional matrix.\n\nThe 3-Dimensional Matrix inverse function is implemented using\nCayley-Hamilton decomposition (mostly just for convenience).\n\n    // GLSL CODE:\n    mat3 matrix = mat3(\n      1.0, 2.0, 3.0,\n      0.0, 1.0, 4.0,\n      5.0, 6.0, 0.0\n    );\n    mat3 matrixInverse = inverse(matrix);\n    //matrixInverse == mat3(\n    //  -24.0, 18.0, 5.0,\n    //   20.0,-15.0,-4.0,\n    //   -5.0,  4.0, 1.0\n    //);",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "mat3Trace",
      "comment": "GLSL Function that computes the trace of a 3-dimensional matrix\n\n    // GLSL CODE:\n    mat3 matrix = mat3(\n      3.0, 9.0, 1.0,\n      6.0, 8.0, 0.0,\n      1.0, 2.0, 1.0\n    );\n    float matrixTrace = trace(matrix);\n    // matrixTrace == 12.0",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "mat3Transpose",
      "comment": "GLSL Function that computes the transpose of a 3-dimensional matrix.\n\n    // GLSL CODE:\n    mat3 matrix = mat3(\n      1.0, 2.0, 3.0,\n      4.0, 5.0, 6.0,\n      7.0, 8.0, 9.0\n    );\n    mat3 transposedMatrix = transpose(matrix);\n    // transposedMatrix == mat3(\n    //      1.0, 4.0, 7.0,\n    //      2.0, 5.0, 8.0,\n    //      3.0, 6.0, 9.0)",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "mat4Determinant",
      "comment": "GLSL Function that computes the determinant of a 4-dimensional matrix\n\n    //GLSL CODE:\n    mat4 matrix = matrix4(\n      2.0, 0.0, 0.0, 0.0,\n      3.0, 4.0, 0.0, 0.0,\n      1.0, 5.0, 9.0, 0.0,\n      0.0, 0.0, 4.0, 2.0\n    );\n    float matrixDeterminant = determinant(matrix);\n    // matrixDeterminant == 72.0",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "mat4Identity",
      "comment": "GLSL 4-Dimensional Identity Matrix\n\n    // GLSL CODE:\n\n    //identity4 == mat4(\n    //    1.0, 0.0, 0.0, 0.0,\n    //    0.0, 1.0, 0.0, 0.0,\n    //    0.0, 0.0, 1.0, 0.0,\n    //    0.0, 0.0, 0.0, 1.0\n    //);",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "mat4Inverse",
      "comment": "GLSL Function that computes the inverse of a 4-Dimensional matrix.\n\nThe 4-Dimensional Matrix inverse function is implemented using\nCayley-Hamilton decomposition (mostly just for convenience).\n\n    //GLSL CODE:\n    mat4 matrix = mat4(\n      4.0, 0.0, 0.0, 0.0,\n      0.0, 0.0, 2.0, 0.0,\n      0.0, 1.0, 2.0, 0.0,\n      1.0, 0.0, 0.0, 1.0\n    );\n    mat4 matrixInverse = inverse(matrix);\n    //matrixInverse == mat4(\n    //  0.25 , 0.0, 0.0, 0.0,\n    //  0.0  ,-1.0, 1.0, 0.0,\n    //  0.0  , 0.5, 0.0, 0.0,\n    //  -0.25, 0.0, 0.0, 1.0\n    //);",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "mat4Trace",
      "comment": "GLSL Function that computes the trace of a 4-dimensional matrix\n\n    // GLSL CODE:\n    mat4 matrix = mat4(\n      2.0, 9.0, 9.0, 1.0,\n      8.0, 7.0, 5.0, 1.0,\n      1.0, 2.0, 3.0, 1.0,\n      1.0, 2.0, 1.0, -12.0\n    );\n    float matrixTrace = trace(matrix);\n    // matrixTrace == 0.0",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "mat4Transpose",
      "comment": "GLSL Function that computes the transpose of a 4-dimensional matrix.\n\n    // GLSL CODE:\n    mat4 matrix = mat4(\n        1.0,  2.0,  3.0,  4.0,\n        5.0,  6.0,  7.0,  8.0,\n        9.0,  10.0, 11.0, 12.0,\n        13.0, 14.0, 15.0, 16.0\n    );\n    mat4 transposedMatrix = transpose(matrix);\n    // transposedMatrix == mat4(\n    //    1.0, 5.0, 9.0,  13.0,\n    //    2.0, 6.0, 10.0, 14.0,\n    //    3.0, 7.0, 11.0, 15.0,\n    //    4.0, 8.0, 12.0, 16.0);",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "traceFunction",
      "comment": "GLSL Function to calculate the trace of a 2, 3, or 4-Dimensional matrix.\n\nThe trace of a matrix represents the derivative of the determinant\n(i.e. the infinitesimal change in area, volume, or hypervolume).\n\nOne of the most common uses of the trace of a matrix is to compute an axis\nand angle from a rotation matrix.\n\n    trace(mat2(1.0, 3.0, 2.0, 12.0)) == 12.0;\n\n    trace(identity4) == 2.0",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "transposeFunction",
      "comment": "GLSL Function to calculate the transpose of a 2,3 or 4-Dimensional matrix.\n\nThe transpose of a matrix is simply the result of switching the rows\nand columns of the input matrix.\n\n    transpose(mat2(1.0, 2.0, 3.0, 4.0)) == mat2(1.0, 3.0, 2.0, 4.0);\n\n    transpose(transpose(matrix)) == matrix;",
      "type": {
        "tag": "type",
        "name": "String"
      }
    }
  ]
}
,
{
  "name": "Engine.Shader.Utils",
  "comment": "This module contains useful values and functions for constructing\nshaders. This includes common shorthands for statements and symbols as well\nas methods to construct attributes, uniforms, structs, or functions.\n\n# Useful Strings\n@docs newLine, whiteSpace, tab, equalSign, comma, semiColon,\n      openParenthesis, closeParenthesis, openCurlyBrace, closeCurlyBrace,\n      commentStart, commentEnd, setFloatPrecision\n\n# Useful Functions\n@docs groupStrings, groupStatements, groupProperties\n\n# Functions to construct GLSL statements\n@docs declareVariable, declareInitializedVariable, declareConstVariable,\n      declareParameter, declareAttribute, declareVarying, declareUniform,\n      declareStructType, callFunctionExpression",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "callFunctionExpression",
      "comment": "Function to construct a function call expression in GLSL\n\n    callFunctionExpression \"add\" [\"x\", \"y\"] == \"add(x, y)\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "type",
                "name": "String"
              }
            ]
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      }
    },
    {
      "name": "closeCurlyBrace",
      "comment": "The close curly brace string : \"}\"",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "closeParenthesis",
      "comment": "The close parenthesis string : \")\"",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "comma",
      "comment": "The comma string : \",\"",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "comment",
      "comment": "Constructs a comment from a string\n\n    comment \"hello\" == \"/*\\nhello\\n*/\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "type",
          "name": "String"
        }
      }
    },
    {
      "name": "commentEnd",
      "comment": "The GLSL multiline comment end string : \"*/\"",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "commentStart",
      "comment": "The GLSL multiline comment start string : \"/*\"",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "declareAttribute",
      "comment": "Function to construct an attribute parameter declaration in GLSL\n\n    declareAttribute \"vec3\" \"position\" == \"attribute vec3 position;\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      }
    },
    {
      "name": "declareConstVariable",
      "comment": "Function to construct a const variable declaration in GLSL\n\n    declareConstVariable \"float\" \"x\" \"3.0\" == \"const float x = 3.0;\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        }
      }
    },
    {
      "name": "declareInitializedVariable",
      "comment": "Function to construct an initialized variable in GLSL\n\n    declareInitializedVariable \"float\" \"x\" \"3.0\" == \"float x = 3.0;\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        }
      }
    },
    {
      "name": "declareParameter",
      "comment": "Function to construct an input parameter declaration in GLSL\n\n    declareParameter \"uniform\" \"float\" \"border\" == \"uniform float border;\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "lambda",
            "in": {
              "tag": "type",
              "name": "String"
            },
            "out": {
              "tag": "type",
              "name": "String"
            }
          }
        }
      }
    },
    {
      "name": "declareStructType",
      "comment": "Function to construct a struct type declaration in GLSL\n\n    declareStructType \"Point\" [(\"float\", \"x\"), (\"float\", \"y\")] ==\n      \"struct Point {\\n\\tfloat x;\\n\\tfloat y;\\n};\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "app",
            "func": {
              "tag": "type",
              "name": "List"
            },
            "args": [
              {
                "tag": "app",
                "func": {
                  "tag": "type",
                  "name": "_Tuple2"
                },
                "args": [
                  {
                    "tag": "type",
                    "name": "String"
                  },
                  {
                    "tag": "type",
                    "name": "String"
                  }
                ]
              }
            ]
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      }
    },
    {
      "name": "declareUniform",
      "comment": "Function to construct a uniform parameter declaration in GLSL\n\n    declareUniform \"mat4\" \"modelMatrix\" == \"uniform mat4 modelMatrix;\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      }
    },
    {
      "name": "declareVariable",
      "comment": "Function to construct a variable declaration in GLSL\nwith a given type and name\n\n    declareVariable \"vec3\" \"position\" == \"vec3 position;\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      }
    },
    {
      "name": "declareVarying",
      "comment": "Function to construct a varying parameter declaration in GLSL\n\n    declareVarying \"vec3\" \"vPosition\" == \"varying vec3 vPosition;\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "type",
          "name": "String"
        },
        "out": {
          "tag": "lambda",
          "in": {
            "tag": "type",
            "name": "String"
          },
          "out": {
            "tag": "type",
            "name": "String"
          }
        }
      }
    },
    {
      "name": "equalSign",
      "comment": "The equal sign string : \"=\"",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "groupProperties",
      "comment": "Groups a list of properties into a single string by interspersing\nnew lines and tabs. (mainly used to construct GLSL struct definitions)\n\n    groupProperties [\"vec3 position;\", \"vec3 rotation;\"] ==\n      \"vec3 position;\\n\\tvec3 rotation;\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "type",
              "name": "String"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "String"
        }
      }
    },
    {
      "name": "groupStatements",
      "comment": "Groups a list of statements into a single string by interspersing\nnew lines.\n\n    groupStatements [\"x = 1;\", \"y = 2;\"] == \"x = 1;\\ny = 2;\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "type",
              "name": "String"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "String"
        }
      }
    },
    {
      "name": "groupStrings",
      "comment": "Groups a list of string into a single string\n\n    groupString [\"Hello\", \"World\"] == \"HelloWorld\"",
      "type": {
        "tag": "lambda",
        "in": {
          "tag": "app",
          "func": {
            "tag": "type",
            "name": "List"
          },
          "args": [
            {
              "tag": "type",
              "name": "String"
            }
          ]
        },
        "out": {
          "tag": "type",
          "name": "String"
        }
      }
    },
    {
      "name": "newLine",
      "comment": "The new line string : \"\\n\"",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "openCurlyBrace",
      "comment": "The open curly brace string : \"{\"",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "openParenthesis",
      "comment": "The open parenthesis string : \"(\"",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "semiColon",
      "comment": "The semicolon string : \";\"",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "setFloatPrecision",
      "comment": "The string : \"precision mediump float;\"",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "tab",
      "comment": "The tab string : \"\\t\"",
      "type": {
        "tag": "type",
        "name": "String"
      }
    },
    {
      "name": "whiteSpace",
      "comment": "The whitespace string : \" \"",
      "type": {
        "tag": "type",
        "name": "String"
      }
    }
  ]
}
,
{
  "name": "Engine.Shader.VertexShader",
  "comment": "This module contains the definition of the default vertex shader.\n\n# Default Vertex Shader\n@docs vertexShader",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "vertexShader",
      "comment": "Default Vertex Shader.\n\nCurrently, the vertex shader just applied the model view projection\ntransformation onto the vertex position and passes the new position\nas a varying to the fragment shader.",
      "type": {
        "tag": "type",
        "name": "String"
      }
    }
  ]
}
,
{
  "name": "Engine.Shader.FragmentShader",
  "comment": "This module contains the definition of the default fragment shader.\n\n# Default Fragment Shader\n@docs fragmentShader",
  "aliases": [],
  "types": [],
  "values": [
    {
      "name": "fragmentShader",
      "comment": "Default fragment shader\n\nCurrently, the fragment shader just sets the fragment color to red.",
      "type": {
        "tag": "type",
        "name": "String"
      }
    }
  ]
}
,
{
  "name": "Engine.Transform.Transform",
  "comment": "This module contains the definition for the Transform type and\nthe default transform object.\n\n# Definition\n@docs Transform\n\n# Default Transform\n@docs transform",
  "aliases": [
    {
      "name": "Transform",
      "comment": "A transform is an object with a position, a rotation, and a scale.\nThis is mean to be able to represent linear transformations in space. As\nsuch, one can model where an object is (position), what is its orientation\n(rotation), and how large is it (scale).",
      "args": [
        "a"
      ],
      "type": {
        "tag": "record",
        "extension": {
          "tag": "var",
          "name": "a"
        },
        "fields": [
          [
            "position",
            {
              "tag": "type",
              "name": "Vec3"
            }
          ],
          [
            "rotation",
            {
              "tag": "type",
              "name": "Vec3"
            }
          ],
          [
            "scale",
            {
              "tag": "type",
              "name": "Vec3"
            }
          ]
        ]
      }
    }
  ],
  "types": [],
  "values": [
    {
      "name": "transform",
      "comment": "Default transform.\n\nDefined as follows:\n\n    transform = {\n      position = vec3 0 0 0,\n      rotation = vec3 0 0 0,\n      scale    = vec3 1 1 1 }",
      "type": {
        "tag": "app",
        "func": {
          "tag": "type",
          "name": "Transform"
        },
        "args": [
          {
            "tag": "record",
            "extension": null,
            "fields": []
          }
        ]
      }
    }
  ]
}
,
{
  "name": "Engine.Viewport.Viewport",
  "comment": "This module contains the definition for the Viewport type and the\ndefault viewport object\n\n# Definition\n@docs Viewport\n\n# Default Viewport\n@docs viewport",
  "aliases": [
    {
      "name": "Viewport",
      "comment": "A Viewport is an object that is supposed to describe the target \"screen\"\nor \"context\" on to which a scene is rendered.\n\nA Viewport has dimensions consisting of a width and a height.",
      "args": [],
      "type": {
        "tag": "record",
        "extension": null,
        "fields": [
          [
            "dimensions",
            {
              "tag": "record",
              "extension": null,
              "fields": [
                [
                  "width",
                  {
                    "tag": "type",
                    "name": "Float"
                  }
                ],
                [
                  "height",
                  {
                    "tag": "type",
                    "name": "Float"
                  }
                ]
              ]
            }
          ]
        ]
      }
    }
  ],
  "types": [],
  "values": [
    {
      "name": "viewport",
      "comment": "Default Viewport. Sets dimensions.width = 400 and dimensions.height = 400.\n(In essence, with the default viewport object your scene will appear in\na 400 by 400 canvas or webgl context).",
      "type": {
        "tag": "type",
        "name": "Viewport"
      }
    }
  ]
}

]